package app.books.tanga.feature.library

import app.books.tanga.data.favorite.FavoriteRepository
import app.books.tanga.data.user.UserRepository
import app.books.tanga.entity.Favorite
import app.books.tanga.entity.FavoriteId
import app.books.tanga.entity.Summary
import app.books.tanga.entity.SummaryId
import app.books.tanga.errors.DomainError
import javax.inject.Inject
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.emitAll
import kotlinx.coroutines.flow.flow

class FavoriteInteractor @Inject constructor(
    private val favoriteRepository: FavoriteRepository,
    private val userRepository: UserRepository
) {
    suspend fun getFavorites(): Result<List<Favorite>> {
        val userId = userRepository.getUserId() ?: return Result.success(emptyList())
        return favoriteRepository.getFavorites(userId.value)
    }

    /**
     * Observe changes to the favorites for the current user
     */
    fun observeFavorites(): Flow<List<Favorite>> = flow {
        val userId = userRepository.getUserId() // This can be a suspending call
        if (userId != null) {
            emitAll(favoriteRepository.getFavoritesStream(userId.value))
        } else {
            emit(emptyList())
        }
    }

    /**
     * Check if a given summary is a favorite.
     */
    suspend fun isFavorite(summaryId: SummaryId): Result<Boolean> {
        val userId = userRepository.getUserId() ?: return Result.success(false)
        val favorite =
            favoriteRepository
                .getFavoriteBySummaryId(summaryId = summaryId, userId = userId.value)
                .getOrThrow()
        return Result.success(favorite != null)
    }

    /**
     * Get the user id, then create the favorite with the given summary
     * [Favorite.id] is provided empty and will be generated and updated after creation by
     * the remote storage system.
     */
    suspend fun createFavorite(summary: Summary): Result<Unit> {
        val userId =
            userRepository.getUserId()
                ?: return Result.failure(DomainError.UserNotAuthenticatedError())
        return favoriteRepository.createFavorite(
            favorite =
            Favorite(
                // will be generated by Firestore and updated after creation
                id = FavoriteId(""),
                title = summary.title,
                author = summary.author,
                coverUrl = summary.coverImageUrl,
                userId = userId.value,
                summaryId = summary.id.value,
                playingLength = summary.playingLength
            )
        )
    }

    suspend fun deleteFavoriteBySummaryId(summaryId: SummaryId): Result<Unit> {
        val userId =
            userRepository.getUserId()
                ?: return Result.failure(DomainError.UserNotAuthenticatedError())
        val favorite =
            favoriteRepository
                .getFavoriteBySummaryId(summaryId = summaryId, userId = userId.value)
                .getOrThrow()
        return if (favorite != null) {
            favoriteRepository.deleteFavorite(favorite)
        } else {
            Result.failure(DomainError.FavoriteNotFoundError())
        }
    }
}
